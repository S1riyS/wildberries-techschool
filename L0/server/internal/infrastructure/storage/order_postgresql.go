package storage

import (
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"log/slog"
	"strings"
	"time"

	"github.com/Masterminds/squirrel"
	"github.com/S1riyS/wildberries-techschool/L0/server/internal/domain"
	"github.com/S1riyS/wildberries-techschool/L0/server/pkg/logger/slogext"
	"github.com/S1riyS/wildberries-techschool/L0/server/pkg/postgresql"
	"github.com/jackc/pgx/v5"
)

const (
	orderColumns = `order_uid, track_number, entry, delivery, payment, items, 
                   locale, internal_signature, customer_id, delivery_service, 
                   shardkey, sm_id, date_created, oof_shard`
)

type OrderRepository struct {
	dbClient   postgresql.Client
	sb         squirrel.StatementBuilderType
	orderCache domain.IOrderCache
}

func NewOrderRepository(dbClient postgresql.Client, orderCache domain.IOrderCache) *OrderRepository {
	return &OrderRepository{
		dbClient:   dbClient,
		sb:         squirrel.StatementBuilder.PlaceholderFormat(squirrel.Dollar),
		orderCache: orderCache,
	}
}

func marshalOrderComponents(order *domain.Order) (deliveryJSON, paymentJSON, itemsJSON []byte, err error) {
	if deliveryJSON, err = json.Marshal(order.Delivery); err != nil {
		return nil, nil, nil, fmt.Errorf("marshal delivery: %w", err)
	}
	if paymentJSON, err = json.Marshal(order.Payment); err != nil {
		return nil, nil, nil, fmt.Errorf("marshal payment: %w", err)
	}
	if itemsJSON, err = json.Marshal(order.Items); err != nil {
		return nil, nil, nil, fmt.Errorf("marshal items: %w", err)
	}
	return deliveryJSON, paymentJSON, itemsJSON, nil
}

func unmarshalOrderComponents(order *domain.Order, deliveryJSON, paymentJSON, itemsJSON []byte) error {
	if err := json.Unmarshal(deliveryJSON, &order.Delivery); err != nil {
		return fmt.Errorf("unmarshal delivery: %w", err)
	}
	if err := json.Unmarshal(paymentJSON, &order.Payment); err != nil {
		return fmt.Errorf("unmarshal payment: %w", err)
	}
	if err := json.Unmarshal(itemsJSON, &order.Items); err != nil {
		return fmt.Errorf("unmarshal items: %w", err)
	}
	return nil
}

func (r *OrderRepository) Save(ctx context.Context, order *domain.Order) error {
	const mark = "storage.OrderRepository.Save"
	logger := slog.With(slog.String("mark", mark))

	// ! Rewrite DateCreated field
	// DateCreated is also randomly generated by faker, so we need to rewrite it
	order.DateCreated = time.Now()

	deliveryJSON, paymentJSON, itemsJSON, err := marshalOrderComponents(order)
	if err != nil {
		return fmt.Errorf("marshal order components: %w", err)
	}

	query, args, err := r.sb.Insert("orders").
		Columns(strings.Split(orderColumns, ", ")...).
		Values(
			order.OrderUID,
			order.TrackNumber,
			order.Entry,
			deliveryJSON,
			paymentJSON,
			itemsJSON,
			order.Locale,
			order.InternalSignature,
			order.CustomerID,
			order.DeliveryService,
			order.Shardkey,
			order.SMID,
			order.DateCreated,
			order.OOFShard,
		).
		ToSql()
	if err != nil {
		logger.Error("Failed to build query", slogext.Err(err))
		return fmt.Errorf("build query: %w", err)
	}

	logger.Debug("Executing query", slog.String("query", query), slog.Any("args", args))
	if _, err = r.dbClient.Exec(ctx, query, args...); err != nil {
		logger.Error("Failed to execute query", slogext.Err(err))
		return fmt.Errorf("execute query: %w", err)
	}

	return nil
}

func (r *OrderRepository) Get(ctx context.Context, orderID string) (*domain.Order, error) {
	const mark = "storage.OrderRepository.Get"
	logger := slog.With(slog.String("mark", mark))

	// Try cache first
	cachedOrder, err := r.orderCache.Get(ctx, orderID)
	if err == nil {
		logger.Debug("Order found in cache", slog.String("order_uid", orderID))
		return cachedOrder, nil
	}

	query, args, err := r.sb.Select(orderColumns).
		From("orders").
		Where(squirrel.Eq{"order_uid": orderID}).
		ToSql()
	if err != nil {
		logger.Error("Failed to build query", slogext.Err(err))
		return nil, fmt.Errorf("build query: %w", err)
	}

	var order domain.Order
	var deliveryJSON, paymentJSON, itemsJSON []byte
	var dateCreated time.Time

	logger.Debug("Executing query", slog.String("query", query), slog.Any("args", args))
	err = r.dbClient.QueryRow(ctx, query, args...).Scan(
		&order.OrderUID,
		&order.TrackNumber,
		&order.Entry,
		&deliveryJSON,
		&paymentJSON,
		&itemsJSON,
		&order.Locale,
		&order.InternalSignature,
		&order.CustomerID,
		&order.DeliveryService,
		&order.Shardkey,
		&order.SMID,
		&dateCreated,
		&order.OOFShard,
	)
	if err != nil {
		if errors.Is(err, pgx.ErrNoRows) {
			logger.Debug("Order not found in database", slog.String("order_uid", orderID))
			return nil, nil
		}

		logger.Error("Failed to execute query", slogext.Err(err))
		return nil, fmt.Errorf("execute query: %w", err)
	}

	order.DateCreated = dateCreated
	if err := unmarshalOrderComponents(&order, deliveryJSON, paymentJSON, itemsJSON); err != nil {
		logger.Error("Failed to unmarshal order components", slogext.Err(err))
		return nil, fmt.Errorf("unmarshal order components: %w", err)
	}

	// Set cache
	if err := r.orderCache.Save(ctx, &order); err != nil {
		logger.Error("Failed to set order in cache", slogext.Err(err))
	}
	return &order, nil
}

func (r *OrderRepository) GetRecentlyCreated(ctx context.Context, limit int) ([]*domain.Order, error) {
	const mark = "storage.OrderRepository.GetRecentlyCreated"
	logger := slog.With(slog.String("mark", mark))

	query, args, err := r.sb.Select(orderColumns).
		From("orders").
		OrderBy("date_created DESC").
		Limit(uint64(limit)).
		ToSql()
	if err != nil {
		logger.Error("Failed to build query", slogext.Err(err))
		return nil, fmt.Errorf("build query: %w", err)
	}

	logger.Debug("Executing query", slog.String("query", query), slog.Any("args", args))
	rows, err := r.dbClient.Query(ctx, query, args...)
	if err != nil {
		logger.Error("Failed to execute query", slogext.Err(err))
		return nil, fmt.Errorf("execute query: %w", err)
	}
	defer rows.Close()

	var orders []*domain.Order
	for rows.Next() {
		var order domain.Order
		var deliveryJSON, paymentJSON, itemsJSON []byte
		var dateCreated time.Time

		err := rows.Scan(
			&order.OrderUID,
			&order.TrackNumber,
			&order.Entry,
			&deliveryJSON,
			&paymentJSON,
			&itemsJSON,
			&order.Locale,
			&order.InternalSignature,
			&order.CustomerID,
			&order.DeliveryService,
			&order.Shardkey,
			&order.SMID,
			&dateCreated,
			&order.OOFShard,
		)
		if err != nil {
			logger.Error("Failed to scan row", slogext.Err(err), slog.String("order_uid", order.OrderUID))
			return nil, fmt.Errorf("scan row: %w", err)
		}

		order.DateCreated = dateCreated
		if err := unmarshalOrderComponents(&order, deliveryJSON, paymentJSON, itemsJSON); err != nil {
			logger.Error("Failed to unmarshal order components", slogext.Err(err), slog.String("order_uid", order.OrderUID))
			return nil, fmt.Errorf("unmarshal components: %w", err)
		}

		orders = append(orders, &order)
	}

	if err := rows.Err(); err != nil {
		logger.Error("Failed to get rows", slogext.Err(err))
		return nil, fmt.Errorf("rows error: %w", err)
	}

	return orders, nil
}
